import{W as w}from"./index-YOKk7ouR.js";function K(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substr(r,2),16);return e}function d(t){const e=String.fromCharCode(...Array.from(t));return btoa(e)}let s=null;async function m(){if(s)return s;const e=(await w.get("/api/crypto/public-key")).data.public_key;return s=e,e}async function h(t){if(!t)return t;try{const e=await m(),r=K(e),c=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveBits"]),i=await crypto.subtle.importKey("raw",r,{name:"ECDH",namedCurve:"P-256"},!1,[]),y=await crypto.subtle.deriveBits({name:"ECDH",public:i},c.privateKey,256),u=await crypto.subtle.importKey("raw",new Uint8Array(y),"HKDF",!1,["deriveBits"]),l=await crypto.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:new Uint8Array(0),info:new TextEncoder().encode("password-encryption")},u,256),p=await crypto.subtle.importKey("raw",new Uint8Array(l),"AES-GCM",!1,["encrypt"]),b=new Uint8Array(12),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:b},p,new TextEncoder().encode(t)),n=await crypto.subtle.exportKey("raw",c.publicKey),a=new Uint8Array(n.byteLength+o.byteLength);return a.set(new Uint8Array(n),0),a.set(new Uint8Array(o),n.byteLength),d(a)}catch(e){throw console.error("密码加密失败:",e),new Error("密码加密失败")}}export{h as e};
