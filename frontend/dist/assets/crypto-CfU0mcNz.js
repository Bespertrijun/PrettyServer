import{W as mn}from"./index-Be7L2w_a.js";const mt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ft(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function $t(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function pt(t,...e){if(!Ft(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function zt(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");$t(t.outputLen),$t(t.blockLen)}function Mt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function En(t,e){pt(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function yt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function Xt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function J(t,e){return t<<32-e|t>>>e}const Ke=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Bn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function At(t){if(pt(t),Ke)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=Bn[t[r]];return e}const nt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Be(t){if(t>=nt._0&&t<=nt._9)return t-nt._0;if(t>=nt.A&&t<=nt.F)return t-(nt.A-10);if(t>=nt.a&&t<=nt.f)return t-(nt.a-10)}function kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(Ke)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){const f=Be(t.charCodeAt(s)),i=Be(t.charCodeAt(s+1));if(f===void 0||i===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[o]=f*16+i}return n}function vn(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Ht(t){return typeof t=="string"&&(t=vn(t)),pt(t),t}function ht(...t){let e=0;for(let n=0;n<t.length;n++){const o=t[n];pt(o),e+=o.length}const r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){const s=t[n];r.set(s,o),o+=s.length}return r}class Ze{}function de(t){const e=n=>t().update(Ht(n)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function Ve(t=32){if(mt&&typeof mt.getRandomValues=="function")return mt.getRandomValues(new Uint8Array(t));if(mt&&typeof mt.randomBytes=="function")return Uint8Array.from(mt.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function An(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const o=BigInt(32),s=BigInt(4294967295),f=Number(r>>o&s),i=Number(r&s),c=n?4:0,l=n?0:4;t.setUint32(e+c,f,n),t.setUint32(e+l,i,n)}function Sn(t,e,r){return t&e^~t&r}function Un(t,e,r){return t&e^t&r^e&r}class $e extends Ze{constructor(e,r,n,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(e),this.view=Xt(this.buffer)}update(e){Mt(this),e=Ht(e),pt(e);const{view:r,buffer:n,blockLen:o}=this,s=e.length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i===o){const c=Xt(e);for(;o<=s-f;f+=o)this.process(c,f);continue}n.set(e.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Mt(this),En(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:o,isLE:s}=this;let{pos:f}=this;r[f++]=128,yt(this.buffer.subarray(f)),this.padOffset>o-f&&(this.process(n,0),f=0);for(let d=f;d<o;d++)r[d]=0;An(n,o-8,BigInt(this.length*8),s),this.process(n,0);const i=Xt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,b=this.get();if(l>b.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)i.setUint32(4*d,b[d],s)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:r,buffer:n,length:o,finished:s,destroyed:f,pos:i}=this;return e.destroyed=f,e.finished=s,e.length=o,e.pos=i,o%r&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const at=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),k=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),G=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Ot=BigInt(2**32-1),ve=BigInt(32);function In(t,e=!1){return e?{h:Number(t&Ot),l:Number(t>>ve&Ot)}:{h:Number(t>>ve&Ot)|0,l:Number(t&Ot)|0}}function Hn(t,e=!1){const r=t.length;let n=new Uint32Array(r),o=new Uint32Array(r);for(let s=0;s<r;s++){const{h:f,l:i}=In(t[s],e);[n[s],o[s]]=[f,i]}return[n,o]}const Ae=(t,e,r)=>t>>>r,Se=(t,e,r)=>t<<32-r|e>>>r,Et=(t,e,r)=>t>>>r|e<<32-r,Bt=(t,e,r)=>t<<32-r|e>>>r,Rt=(t,e,r)=>t<<64-r|e>>>r-32,Tt=(t,e,r)=>t>>>r-32|e<<64-r;function rt(t,e,r,n){const o=(e>>>0)+(n>>>0);return{h:t+r+(o/2**32|0)|0,l:o|0}}const _n=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),Ln=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,Nn=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),On=(t,e,r,n,o)=>e+r+n+o+(t/2**32|0)|0,Rn=(t,e,r,n,o)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(o>>>0),Tn=(t,e,r,n,o,s)=>e+r+n+o+s+(t/2**32|0)|0,Cn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),lt=new Uint32Array(64);class qn extends $e{constructor(e=32){super(64,e,8,!1),this.A=at[0]|0,this.B=at[1]|0,this.C=at[2]|0,this.D=at[3]|0,this.E=at[4]|0,this.F=at[5]|0,this.G=at[6]|0,this.H=at[7]|0}get(){const{A:e,B:r,C:n,D:o,E:s,F:f,G:i,H:c}=this;return[e,r,n,o,s,f,i,c]}set(e,r,n,o,s,f,i,c){this.A=e|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(e,r){for(let d=0;d<16;d++,r+=4)lt[d]=e.getUint32(r,!1);for(let d=16;d<64;d++){const a=lt[d-15],u=lt[d-2],y=J(a,7)^J(a,18)^a>>>3,p=J(u,17)^J(u,19)^u>>>10;lt[d]=p+lt[d-7]+y+lt[d-16]|0}let{A:n,B:o,C:s,D:f,E:i,F:c,G:l,H:b}=this;for(let d=0;d<64;d++){const a=J(i,6)^J(i,11)^J(i,25),u=b+a+Sn(i,c,l)+Cn[d]+lt[d]|0,p=(J(n,2)^J(n,13)^J(n,22))+Un(n,o,s)|0;b=l,l=c,c=i,i=f+u|0,f=s,s=o,o=n,n=u+p|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,l=l+this.G|0,b=b+this.H|0,this.set(n,o,s,f,i,c,l,b)}roundClean(){yt(lt)}destroy(){this.set(0,0,0,0,0,0,0,0),yt(this.buffer)}}const Me=Hn(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),Kn=Me[0],Zn=Me[1],ut=new Uint32Array(80),dt=new Uint32Array(80);class ke extends $e{constructor(e=64){super(128,e,16,!1),this.Ah=G[0]|0,this.Al=G[1]|0,this.Bh=G[2]|0,this.Bl=G[3]|0,this.Ch=G[4]|0,this.Cl=G[5]|0,this.Dh=G[6]|0,this.Dl=G[7]|0,this.Eh=G[8]|0,this.El=G[9]|0,this.Fh=G[10]|0,this.Fl=G[11]|0,this.Gh=G[12]|0,this.Gl=G[13]|0,this.Hh=G[14]|0,this.Hl=G[15]|0}get(){const{Ah:e,Al:r,Bh:n,Bl:o,Ch:s,Cl:f,Dh:i,Dl:c,Eh:l,El:b,Fh:d,Fl:a,Gh:u,Gl:y,Hh:p,Hl:S}=this;return[e,r,n,o,s,f,i,c,l,b,d,a,u,y,p,S]}set(e,r,n,o,s,f,i,c,l,b,d,a,u,y,p,S){this.Ah=e|0,this.Al=r|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=f|0,this.Dh=i|0,this.Dl=c|0,this.Eh=l|0,this.El=b|0,this.Fh=d|0,this.Fl=a|0,this.Gh=u|0,this.Gl=y|0,this.Hh=p|0,this.Hl=S|0}process(e,r){for(let B=0;B<16;B++,r+=4)ut[B]=e.getUint32(r),dt[B]=e.getUint32(r+=4);for(let B=16;B<80;B++){const R=ut[B-15]|0,K=dt[B-15]|0,P=Et(R,K,1)^Et(R,K,8)^Ae(R,K,7),Q=Bt(R,K,1)^Bt(R,K,8)^Se(R,K,7),$=ut[B-2]|0,U=dt[B-2]|0,et=Et($,U,19)^Rt($,U,61)^Ae($,U,6),W=Bt($,U,19)^Tt($,U,61)^Se($,U,6),L=Nn(Q,W,dt[B-7],dt[B-16]),w=On(L,P,et,ut[B-7],ut[B-16]);ut[B]=w|0,dt[B]=L|0}let{Ah:n,Al:o,Bh:s,Bl:f,Ch:i,Cl:c,Dh:l,Dl:b,Eh:d,El:a,Fh:u,Fl:y,Gh:p,Gl:S,Hh:_,Hl:O}=this;for(let B=0;B<80;B++){const R=Et(d,a,14)^Et(d,a,18)^Rt(d,a,41),K=Bt(d,a,14)^Bt(d,a,18)^Tt(d,a,41),P=d&u^~d&p,Q=a&y^~a&S,$=Rn(O,K,Q,Zn[B],dt[B]),U=Tn($,_,R,P,Kn[B],ut[B]),et=$|0,W=Et(n,o,28)^Rt(n,o,34)^Rt(n,o,39),L=Bt(n,o,28)^Tt(n,o,34)^Tt(n,o,39),w=n&s^n&i^s&i,g=o&f^o&c^f&c;_=p|0,O=S|0,p=u|0,S=y|0,u=d|0,y=a|0,{h:d,l:a}=rt(l|0,b|0,U|0,et|0),l=i|0,b=c|0,i=s|0,c=f|0,s=n|0,f=o|0;const h=_n(et,L,g);n=Ln(h,U,W,w),o=h|0}({h:n,l:o}=rt(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:f}=rt(this.Bh|0,this.Bl|0,s|0,f|0),{h:i,l:c}=rt(this.Ch|0,this.Cl|0,i|0,c|0),{h:l,l:b}=rt(this.Dh|0,this.Dl|0,l|0,b|0),{h:d,l:a}=rt(this.Eh|0,this.El|0,d|0,a|0),{h:u,l:y}=rt(this.Fh|0,this.Fl|0,u|0,y|0),{h:p,l:S}=rt(this.Gh|0,this.Gl|0,p|0,S|0),{h:_,l:O}=rt(this.Hh|0,this.Hl|0,_|0,O|0),this.set(n,o,s,f,i,c,l,b,d,a,u,y,p,S,_,O)}roundClean(){yt(ut,dt)}destroy(){yt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Vn extends ke{constructor(){super(48),this.Ah=k[0]|0,this.Al=k[1]|0,this.Bh=k[2]|0,this.Bl=k[3]|0,this.Ch=k[4]|0,this.Cl=k[5]|0,this.Dh=k[6]|0,this.Dl=k[7]|0,this.Eh=k[8]|0,this.El=k[9]|0,this.Fh=k[10]|0,this.Fl=k[11]|0,this.Gh=k[12]|0,this.Gl=k[13]|0,this.Hh=k[14]|0,this.Hl=k[15]|0}}const Ge=de(()=>new qn),$n=de(()=>new ke),Mn=de(()=>new Vn);class je extends Ze{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,zt(e);const n=Ht(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?e.create().update(n).digest():n);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),yt(s)}update(e){return Mt(this),this.iHash.update(e),this}digestInto(e){Mt(this),pt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=i,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Dt=(t,e,r)=>new je(t,e).update(r).digest();Dt.create=(t,e)=>new je(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt(0),ce=BigInt(1);function Gt(t,e=""){if(typeof t!="boolean"){const r=e&&`"${e}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function bt(t,e,r=""){const n=Ft(t),o=t==null?void 0:t.length,s=e!==void 0;if(!n||s&&o!==e){const f=r&&`"${r}" `,i=s?` of length ${e}`:"",c=n?`length=${o}`:`type=${typeof t}`;throw new Error(f+"expected Uint8Array"+i+", got "+c)}return t}function Ct(t){const e=t.toString(16);return e.length&1?"0"+e:e}function Ye(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?he:BigInt("0x"+t)}function Pt(t){return Ye(At(t))}function Fe(t){return pt(t),Ye(At(Uint8Array.from(t).reverse()))}function be(t,e){return kt(t.toString(16).padStart(e*2,"0"))}function ze(t,e){return be(t,e).reverse()}function F(t,e,r){let n;if(typeof e=="string")try{n=kt(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(Ft(e))n=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");return n.length,n}const Qt=t=>typeof t=="bigint"&&he<=t;function kn(t,e,r){return Qt(t)&&Qt(e)&&Qt(r)&&e<=t&&t<r}function Gn(t,e,r,n){if(!kn(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function De(t){let e;for(e=0;t>he;t>>=ce,e+=1);return e}const Lt=t=>(ce<<BigInt(t))-ce;function jn(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const n=u=>new Uint8Array(u),o=u=>Uint8Array.of(u);let s=n(t),f=n(t),i=0;const c=()=>{s.fill(1),f.fill(0),i=0},l=(...u)=>r(f,s,...u),b=(u=n(0))=>{f=l(o(0),u),s=l(),u.length!==0&&(f=l(o(1),u),s=l())},d=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const y=[];for(;u<e;){s=l();const p=s.slice();y.push(p),u+=s.length}return ht(...y)};return(u,y)=>{c(),b(u);let p;for(;!(p=y(d()));)b();return c(),p}}function ge(t,e,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function n(o,s,f){const i=t[o];if(f&&i===void 0)return;const c=typeof i;if(c!==s||i===null)throw new Error(`param "${o}" is invalid: expected ${s}, got ${c}`)}Object.entries(e).forEach(([o,s])=>n(o,s,!1)),Object.entries(r).forEach(([o,s])=>n(o,s,!0))}function Ue(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(o!==void 0)return o;const s=t(r,...n);return e.set(r,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const z=BigInt(0),j=BigInt(1),gt=BigInt(2),Pe=BigInt(3),We=BigInt(4),Xe=BigInt(5),Yn=BigInt(7),Qe=BigInt(8),Fn=BigInt(9),Je=BigInt(16);function X(t,e){const r=t%e;return r>=z?r:e+r}function Ie(t,e){if(t===z)throw new Error("invert: expected non-zero number");if(e<=z)throw new Error("invert: expected positive modulus, got "+e);let r=X(t,e),n=e,o=z,s=j;for(;r!==z;){const i=n/r,c=n%r,l=o-s*i;n=r,r=c,o=s,s=l}if(n!==j)throw new Error("invert: does not exist");return X(o,e)}function we(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function tn(t,e){const r=(t.ORDER+j)/We,n=t.pow(e,r);return we(t,n,e),n}function zn(t,e){const r=(t.ORDER-Xe)/Qe,n=t.mul(e,gt),o=t.pow(n,r),s=t.mul(e,o),f=t.mul(t.mul(s,gt),o),i=t.mul(s,t.sub(f,t.ONE));return we(t,i,e),i}function Dn(t){const e=xt(t),r=en(t),n=r(e,e.neg(e.ONE)),o=r(e,n),s=r(e,e.neg(n)),f=(t+Yn)/Je;return(i,c)=>{let l=i.pow(c,f),b=i.mul(l,n);const d=i.mul(l,o),a=i.mul(l,s),u=i.eql(i.sqr(b),c),y=i.eql(i.sqr(d),c);l=i.cmov(l,b,u),b=i.cmov(a,d,y);const p=i.eql(i.sqr(b),c),S=i.cmov(l,b,p);return we(i,S,c),S}}function en(t){if(t<Pe)throw new Error("sqrt is not defined for small field");let e=t-j,r=0;for(;e%gt===z;)e/=gt,r++;let n=gt;const o=xt(t);for(;He(o,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return tn;let s=o.pow(n,e);const f=(e+j)/gt;return function(c,l){if(c.is0(l))return l;if(He(c,l)!==1)throw new Error("Cannot find square root");let b=r,d=c.mul(c.ONE,s),a=c.pow(l,e),u=c.pow(l,f);for(;!c.eql(a,c.ONE);){if(c.is0(a))return c.ZERO;let y=1,p=c.sqr(a);for(;!c.eql(p,c.ONE);)if(y++,p=c.sqr(p),y===b)throw new Error("Cannot find square root");const S=j<<BigInt(b-y-1),_=c.pow(d,S);b=y,d=c.sqr(_),a=c.mul(a,d),u=c.mul(u,_)}return u}}function Pn(t){return t%We===Pe?tn:t%Qe===Xe?zn:t%Je===Fn?Dn(t):en(t)}const Wn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Xn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=Wn.reduce((n,o)=>(n[o]="function",n),e);return ge(t,r),t}function Qn(t,e,r){if(r<z)throw new Error("invalid exponent, negatives unsupported");if(r===z)return t.ONE;if(r===j)return e;let n=t.ONE,o=e;for(;r>z;)r&j&&(n=t.mul(n,o)),o=t.sqr(o),r>>=j;return n}function nn(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),o=e.reduce((f,i,c)=>t.is0(i)?f:(n[c]=f,t.mul(f,i)),t.ONE),s=t.inv(o);return e.reduceRight((f,i,c)=>t.is0(i)?f:(n[c]=t.mul(f,n[c]),t.mul(f,i)),s),n}function He(t,e){const r=(t.ORDER-j)/gt,n=t.pow(e,r),o=t.eql(n,t.ONE),s=t.eql(n,t.ZERO),f=t.eql(n,t.neg(t.ONE));if(!o&&!s&&!f)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function rn(t,e){e!==void 0&&$t(e);const r=e!==void 0?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function xt(t,e,r=!1,n={}){if(t<=z)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,s,f=!1,i;if(typeof e=="object"&&e!=null){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const a=e;a.BITS&&(o=a.BITS),a.sqrt&&(s=a.sqrt),typeof a.isLE=="boolean"&&(r=a.isLE),typeof a.modFromBytes=="boolean"&&(f=a.modFromBytes),i=a.allowedLengths}else typeof e=="number"&&(o=e),n.sqrt&&(s=n.sqrt);const{nBitLength:c,nByteLength:l}=rn(t,o);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const d=Object.freeze({ORDER:t,isLE:r,BITS:c,BYTES:l,MASK:Lt(c),ZERO:z,ONE:j,allowedLengths:i,create:a=>X(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return z<=a&&a<t},is0:a=>a===z,isValidNot0:a=>!d.is0(a)&&d.isValid(a),isOdd:a=>(a&j)===j,neg:a=>X(-a,t),eql:(a,u)=>a===u,sqr:a=>X(a*a,t),add:(a,u)=>X(a+u,t),sub:(a,u)=>X(a-u,t),mul:(a,u)=>X(a*u,t),pow:(a,u)=>Qn(d,a,u),div:(a,u)=>X(a*Ie(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>Ie(a,t),sqrt:s||(a=>(b||(b=Pn(t)),b(d,a))),toBytes:a=>r?ze(a,l):be(a,l),fromBytes:(a,u=!0)=>{if(i){if(!i.includes(a.length)||a.length>l)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+a.length);const p=new Uint8Array(l);p.set(a,r?0:p.length-a.length),a=p}if(a.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+a.length);let y=r?Fe(a):Pt(a);if(f&&(y=X(y,t)),!u&&!d.isValid(y))throw new Error("invalid field element: outside of range 0..ORDER");return y},invertBatch:a=>nn(d,a),cmov:(a,u,y)=>y?u:a});return Object.freeze(d)}function on(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function sn(t){const e=on(t);return e+Math.ceil(e/2)}function Jn(t,e,r=!1){const n=t.length,o=on(e),s=sn(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const f=r?Fe(t):Pt(t),i=X(f,e-j)+j;return r?ze(i,o):be(i,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt(0),wt=BigInt(1);function jt(t,e){const r=e.negate();return t?r:e}function Jt(t,e){const r=nn(t.Fp,e.map(n=>n.Z));return e.map((n,o)=>t.fromAffine(n.toAffine(r[o])))}function fn(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function te(t,e){fn(t,e);const r=Math.ceil(e/t)+1,n=2**(t-1),o=2**t,s=Lt(t),f=BigInt(t);return{windows:r,windowSize:n,mask:s,maxNumber:o,shiftBy:f}}function _e(t,e,r){const{windowSize:n,mask:o,maxNumber:s,shiftBy:f}=r;let i=Number(t&o),c=t>>f;i>n&&(i-=s,c+=wt);const l=e*n,b=l+Math.abs(i)-1,d=i===0,a=i<0,u=e%2!==0;return{nextN:c,offset:b,isZero:d,isNeg:a,isNegF:u,offsetF:l}}function tr(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,n)=>{if(!(r instanceof e))throw new Error("invalid point at index "+n)})}function er(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,n)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+n)})}const ee=new WeakMap,cn=new WeakMap;function ne(t){return cn.get(t)||1}function Le(t){if(t!==Ut)throw new Error("invalid wNAF")}class nr{constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,n=this.ZERO){let o=e;for(;r>Ut;)r&wt&&(n=n.add(o)),o=o.double(),r>>=wt;return n}precomputeWindow(e,r){const{windows:n,windowSize:o}=te(r,this.bits),s=[];let f=e,i=f;for(let c=0;c<n;c++){i=f,s.push(i);for(let l=1;l<o;l++)i=i.add(f),s.push(i);f=i.double()}return s}wNAF(e,r,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const f=te(e,this.bits);for(let i=0;i<f.windows;i++){const{nextN:c,offset:l,isZero:b,isNeg:d,isNegF:a,offsetF:u}=_e(n,i,f);n=c,b?s=s.add(jt(a,r[u])):o=o.add(jt(d,r[l]))}return Le(n),{p:o,f:s}}wNAFUnsafe(e,r,n,o=this.ZERO){const s=te(e,this.bits);for(let f=0;f<s.windows&&n!==Ut;f++){const{nextN:i,offset:c,isZero:l,isNeg:b}=_e(n,f,s);if(n=i,!l){const d=r[c];o=o.add(b?d.negate():d)}}return Le(n),o}getPrecomputes(e,r,n){let o=ee.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&(typeof n=="function"&&(o=n(o)),ee.set(r,o))),o}cached(e,r,n){const o=ne(e);return this.wNAF(o,this.getPrecomputes(o,e,n),r)}unsafe(e,r,n,o){const s=ne(e);return s===1?this._unsafeLadder(e,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),r,o)}createCache(e,r){fn(r,this.bits),cn.set(e,r),ee.delete(e)}hasCache(e){return ne(e)!==1}}function rr(t,e,r,n){let o=e,s=t.ZERO,f=t.ZERO;for(;r>Ut||n>Ut;)r&wt&&(s=s.add(o)),n&wt&&(f=f.add(o)),o=o.double(),r>>=wt,n>>=wt;return{p1:s,p2:f}}function or(t,e,r,n){tr(r,t),er(n,e);const o=r.length,s=n.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,i=De(BigInt(o));let c=1;i>12?c=i-3:i>4?c=i-2:i>0&&(c=2);const l=Lt(c),b=new Array(Number(l)+1).fill(f),d=Math.floor((e.BITS-1)/c)*c;let a=f;for(let u=d;u>=0;u-=c){b.fill(f);for(let p=0;p<s;p++){const S=n[p],_=Number(S>>BigInt(u)&l);b[_]=b[_].add(r[p])}let y=f;for(let p=b.length-1,S=f;p>0;p--)S=S.add(b[p]),y=y.add(S);if(a=a.add(y),u!==0)for(let p=0;p<c;p++)a=a.double()}return a}function Ne(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Xn(e),e}else return xt(t,{isLE:r})}function sr(t,e,r={},n){if(n===void 0&&(n=t==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${t} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>Ut))throw new Error(`CURVE.${c} must be positive bigint`)}const o=Ne(e.p,r.Fp,n),s=Ne(e.n,r.Fn,n),i=["Gx","Gy","a","b"];for(const c of i)if(!o.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:o,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Oe=(t,e)=>(t+(t>=0?e:-e)/an)/e;function fr(t,e,r){const[[n,o],[s,f]]=e,i=Oe(f*t,r),c=Oe(-o*t,r);let l=t-i*n-c*s,b=-i*o-c*f;const d=l<ft,a=b<ft;d&&(l=-l),a&&(b=-b);const u=Lt(Math.ceil(De(r)/2))+St;if(l<ft||l>=u||b<ft||b>=u)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:d,k1:l,k2neg:a,k2:b}}function ae(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function re(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return Gt(r.lowS,"lowS"),Gt(r.prehash,"prehash"),r.format!==void 0&&ae(r.format),r}class ir extends Error{constructor(e=""){super(e)}}const ot={Err:ir,_tlv:{encode:(t,e)=>{const{Err:r}=ot;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=Ct(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?Ct(o.length/2|128):"";return Ct(t)+s+o+e},decode(t,e){const{Err:r}=ot;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++],s=!!(o&128);let f=0;if(!s)f=o;else{const c=o&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new r("tlv.decode: length bytes not complete");if(l[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const b of l)f=f<<8|b;if(n+=c,f<128)throw new r("tlv.decode(long): not minimal encoding")}const i=e.subarray(n,n+f);if(i.length!==f)throw new r("tlv.decode: wrong value length");return{v:i,l:e.subarray(n+f)}}},_int:{encode(t){const{Err:e}=ot;if(t<ft)throw new e("integer: negative integers are not allowed");let r=Ct(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=ot;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Pt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=ot,o=F("signature",t),{v:s,l:f}=n.decode(48,o);if(f.length)throw new e("invalid signature: left bytes after parsing");const{v:i,l:c}=n.decode(2,s),{v:l,l:b}=n.decode(2,c);if(b.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(i),s:r.decode(l)}},hexFromSig(t){const{_tlv:e,_int:r}=ot,n=e.encode(2,r.encode(t.r)),o=e.encode(2,r.encode(t.s)),s=n+o;return e.encode(48,s)}},ft=BigInt(0),St=BigInt(1),an=BigInt(2),qt=BigInt(3),cr=BigInt(4);function vt(t,e){const{BYTES:r}=t;let n;if(typeof e=="bigint")n=e;else{let o=F("private key",e);try{n=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!t.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function ar(t,e={}){const r=sr("weierstrass",t,e),{Fp:n,Fn:o}=r;let s=r.CURVE;const{h:f,n:i}=s;ge(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=e;if(c&&(!n.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=un(n,o);function b(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(L,w,g){const{x:h,y:x}=w.toAffine(),m=n.toBytes(h);if(Gt(g,"isCompressed"),g){b();const A=!n.isOdd(x);return ht(ln(A),m)}else return ht(Uint8Array.of(4),m,n.toBytes(x))}function a(L){bt(L,void 0,"Point");const{publicKey:w,publicKeyUncompressed:g}=l,h=L.length,x=L[0],m=L.subarray(1);if(h===w&&(x===2||x===3)){const A=n.fromBytes(m);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const v=p(A);let E;try{E=n.sqrt(v)}catch(Z){const T=Z instanceof Error?": "+Z.message:"";throw new Error("bad point: is not on curve, sqrt error"+T)}b();const I=n.isOdd(E);return(x&1)===1!==I&&(E=n.neg(E)),{x:A,y:E}}else if(h===g&&x===4){const A=n.BYTES,v=n.fromBytes(m.subarray(0,A)),E=n.fromBytes(m.subarray(A,A*2));if(!S(v,E))throw new Error("bad point: is not on curve");return{x:v,y:E}}else throw new Error(`bad point: got length ${h}, expected compressed=${w} or uncompressed=${g}`)}const u=e.toBytes||d,y=e.fromBytes||a;function p(L){const w=n.sqr(L),g=n.mul(w,L);return n.add(n.add(g,n.mul(L,s.a)),s.b)}function S(L,w){const g=n.sqr(w),h=p(L);return n.eql(g,h)}if(!S(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const _=n.mul(n.pow(s.a,qt),cr),O=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(_,O)))throw new Error("bad curve params: a or b");function B(L,w,g=!1){if(!n.isValid(w)||g&&n.is0(w))throw new Error(`bad point coordinate ${L}`);return w}function R(L){if(!(L instanceof U))throw new Error("ProjectivePoint expected")}function K(L){if(!c||!c.basises)throw new Error("no endo");return fr(L,c.basises,o.ORDER)}const P=Ue((L,w)=>{const{X:g,Y:h,Z:x}=L;if(n.eql(x,n.ONE))return{x:g,y:h};const m=L.is0();w==null&&(w=m?n.ONE:n.inv(x));const A=n.mul(g,w),v=n.mul(h,w),E=n.mul(x,w);if(m)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:A,y:v}}),Q=Ue(L=>{if(L.is0()){if(e.allowInfinityPoint&&!n.is0(L.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:g}=L.toAffine();if(!n.isValid(w)||!n.isValid(g))throw new Error("bad point: x or y not field elements");if(!S(w,g))throw new Error("bad point: equation left != right");if(!L.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function $(L,w,g,h,x){return g=new U(n.mul(g.X,L),g.Y,g.Z),w=jt(h,w),g=jt(x,g),w.add(g)}class U{constructor(w,g,h){this.X=B("x",w),this.Y=B("y",g,!0),this.Z=B("z",h),Object.freeze(this)}static CURVE(){return s}static fromAffine(w){const{x:g,y:h}=w||{};if(!w||!n.isValid(g)||!n.isValid(h))throw new Error("invalid affine point");if(w instanceof U)throw new Error("projective point not allowed");return n.is0(g)&&n.is0(h)?U.ZERO:new U(g,h,n.ONE)}static fromBytes(w){const g=U.fromAffine(y(bt(w,void 0,"point")));return g.assertValidity(),g}static fromHex(w){return U.fromBytes(F("pointHex",w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,g=!0){return W.createCache(this,w),g||this.multiply(qt),this}assertValidity(){Q(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){R(w);const{X:g,Y:h,Z:x}=this,{X:m,Y:A,Z:v}=w,E=n.eql(n.mul(g,v),n.mul(m,x)),I=n.eql(n.mul(h,v),n.mul(A,x));return E&&I}negate(){return new U(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b:g}=s,h=n.mul(g,qt),{X:x,Y:m,Z:A}=this;let v=n.ZERO,E=n.ZERO,I=n.ZERO,H=n.mul(x,x),Z=n.mul(m,m),T=n.mul(A,A),N=n.mul(x,m);return N=n.add(N,N),I=n.mul(x,A),I=n.add(I,I),v=n.mul(w,I),E=n.mul(h,T),E=n.add(v,E),v=n.sub(Z,E),E=n.add(Z,E),E=n.mul(v,E),v=n.mul(N,v),I=n.mul(h,I),T=n.mul(w,T),N=n.sub(H,T),N=n.mul(w,N),N=n.add(N,I),I=n.add(H,H),H=n.add(I,H),H=n.add(H,T),H=n.mul(H,N),E=n.add(E,H),T=n.mul(m,A),T=n.add(T,T),H=n.mul(T,N),v=n.sub(v,H),I=n.mul(T,Z),I=n.add(I,I),I=n.add(I,I),new U(v,E,I)}add(w){R(w);const{X:g,Y:h,Z:x}=this,{X:m,Y:A,Z:v}=w;let E=n.ZERO,I=n.ZERO,H=n.ZERO;const Z=s.a,T=n.mul(s.b,qt);let N=n.mul(g,m),C=n.mul(h,A),V=n.mul(x,v),Y=n.add(g,h),q=n.add(m,A);Y=n.mul(Y,q),q=n.add(N,C),Y=n.sub(Y,q),q=n.add(g,x);let M=n.add(m,v);return q=n.mul(q,M),M=n.add(N,V),q=n.sub(q,M),M=n.add(h,x),E=n.add(A,v),M=n.mul(M,E),E=n.add(C,V),M=n.sub(M,E),H=n.mul(Z,q),E=n.mul(T,V),H=n.add(E,H),E=n.sub(C,H),H=n.add(C,H),I=n.mul(E,H),C=n.add(N,N),C=n.add(C,N),V=n.mul(Z,V),q=n.mul(T,q),C=n.add(C,V),V=n.sub(N,V),V=n.mul(Z,V),q=n.add(q,V),N=n.mul(C,q),I=n.add(I,N),N=n.mul(M,q),E=n.mul(Y,E),E=n.sub(E,N),N=n.mul(Y,C),H=n.mul(M,H),H=n.add(H,N),new U(E,I,H)}subtract(w){return this.add(w.negate())}is0(){return this.equals(U.ZERO)}multiply(w){const{endo:g}=e;if(!o.isValidNot0(w))throw new Error("invalid scalar: out of range");let h,x;const m=A=>W.cached(this,A,v=>Jt(U,v));if(g){const{k1neg:A,k1:v,k2neg:E,k2:I}=K(w),{p:H,f:Z}=m(v),{p:T,f:N}=m(I);x=Z.add(N),h=$(g.beta,H,T,A,E)}else{const{p:A,f:v}=m(w);h=A,x=v}return Jt(U,[h,x])[0]}multiplyUnsafe(w){const{endo:g}=e,h=this;if(!o.isValid(w))throw new Error("invalid scalar: out of range");if(w===ft||h.is0())return U.ZERO;if(w===St)return h;if(W.hasCache(this))return this.multiply(w);if(g){const{k1neg:x,k1:m,k2neg:A,k2:v}=K(w),{p1:E,p2:I}=rr(U,h,m,v);return $(g.beta,E,I,x,A)}else return W.unsafe(h,w)}multiplyAndAddUnsafe(w,g,h){const x=this.multiplyUnsafe(g).add(w.multiplyUnsafe(h));return x.is0()?void 0:x}toAffine(w){return P(this,w)}isTorsionFree(){const{isTorsionFree:w}=e;return f===St?!0:w?w(U,this):W.unsafe(this,i).is0()}clearCofactor(){const{clearCofactor:w}=e;return f===St?this:w?w(U,this):this.multiplyUnsafe(f)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}toBytes(w=!0){return Gt(w,"isCompressed"),this.assertValidity(),u(U,this,w)}toHex(w=!0){return At(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(w=!0){return this.toBytes(w)}_setWindowSize(w){this.precompute(w)}static normalizeZ(w){return Jt(U,w)}static msm(w,g){return or(U,o,w,g)}static fromPrivateKey(w){return U.BASE.multiply(vt(o,w))}}U.BASE=new U(s.Gx,s.Gy,n.ONE),U.ZERO=new U(n.ZERO,n.ONE,n.ZERO),U.Fp=n,U.Fn=o;const et=o.BITS,W=new nr(U,e.endo?Math.ceil(et/2):et);return U.BASE.precompute(8),U}function ln(t){return Uint8Array.of(t?2:3)}function un(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function lr(t,e={}){const{Fn:r}=t,n=e.randomBytes||Ve,o=Object.assign(un(t.Fp,r),{seed:sn(r.ORDER)});function s(u){try{return!!vt(r,u)}catch{return!1}}function f(u,y){const{publicKey:p,publicKeyUncompressed:S}=o;try{const _=u.length;return y===!0&&_!==p||y===!1&&_!==S?!1:!!t.fromBytes(u)}catch{return!1}}function i(u=n(o.seed)){return Jn(bt(u,o.seed,"seed"),r.ORDER)}function c(u,y=!0){return t.BASE.multiply(vt(r,u)).toBytes(y)}function l(u){const y=i(u);return{secretKey:y,publicKey:c(y)}}function b(u){if(typeof u=="bigint")return!1;if(u instanceof t)return!0;const{secretKey:y,publicKey:p,publicKeyUncompressed:S}=o;if(r.allowedLengths||y===p)return;const _=F("key",u).length;return _===p||_===S}function d(u,y,p=!0){if(b(u)===!0)throw new Error("first arg must be private key");if(b(y)===!1)throw new Error("second arg must be public key");const S=vt(r,u);return t.fromHex(y).multiply(S).toBytes(p)}return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:l,Point:t,utils:{isValidSecretKey:s,isValidPublicKey:f,randomSecretKey:i,isValidPrivateKey:s,randomPrivateKey:i,normPrivateKeyToScalar:u=>vt(r,u),precompute(u=8,y=t.BASE){return y.precompute(u,!1)}},lengths:o})}function ur(t,e,r={}){zt(e),ge(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||Ve,o=r.hmac||((g,...h)=>Dt(e,g,ht(...h))),{Fp:s,Fn:f}=t,{ORDER:i,BITS:c}=f,{keygen:l,getPublicKey:b,getSharedSecret:d,utils:a,lengths:u}=lr(t,r),y={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},p="compact";function S(g){const h=i>>St;return g>h}function _(g,h){if(!f.isValidNot0(h))throw new Error(`invalid signature ${g}: out of range 1..Point.Fn.ORDER`);return h}function O(g,h){ae(h);const x=u.signature,m=h==="compact"?x:h==="recovered"?x+1:void 0;return bt(g,m,`${h} signature`)}class B{constructor(h,x,m){this.r=_("r",h),this.s=_("s",x),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(h,x=p){O(h,x);let m;if(x==="der"){const{r:I,s:H}=ot.toSig(bt(h));return new B(I,H)}x==="recovered"&&(m=h[0],x="compact",h=h.subarray(1));const A=f.BYTES,v=h.subarray(0,A),E=h.subarray(A,A*2);return new B(f.fromBytes(v),f.fromBytes(E),m)}static fromHex(h,x){return this.fromBytes(kt(h),x)}addRecoveryBit(h){return new B(this.r,this.s,h)}recoverPublicKey(h){const x=s.ORDER,{r:m,s:A,recovery:v}=this;if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");if(i*an<x&&v>1)throw new Error("recovery id is ambiguous for h>1 curve");const I=v===2||v===3?m+i:m;if(!s.isValid(I))throw new Error("recovery id 2 or 3 invalid");const H=s.toBytes(I),Z=t.fromBytes(ht(ln((v&1)===0),H)),T=f.inv(I),N=K(F("msgHash",h)),C=f.create(-N*T),V=f.create(A*T),Y=t.BASE.multiplyUnsafe(C).add(Z.multiplyUnsafe(V));if(Y.is0())throw new Error("point at infinify");return Y.assertValidity(),Y}hasHighS(){return S(this.s)}toBytes(h=p){if(ae(h),h==="der")return kt(ot.hexFromSig(this));const x=f.toBytes(this.r),m=f.toBytes(this.s);if(h==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return ht(Uint8Array.of(this.recovery),x,m)}return ht(x,m)}toHex(h){return At(this.toBytes(h))}assertValidity(){}static fromCompact(h){return B.fromBytes(F("sig",h),"compact")}static fromDER(h){return B.fromBytes(F("sig",h),"der")}normalizeS(){return this.hasHighS()?new B(this.r,f.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return At(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return At(this.toBytes("compact"))}}const R=r.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const x=Pt(h),m=h.length*8-c;return m>0?x>>BigInt(m):x},K=r.bits2int_modN||function(h){return f.create(R(h))},P=Lt(c);function Q(g){return Gn("num < 2^"+c,g,ft,P),f.toBytes(g)}function $(g,h){return bt(g,void 0,"message"),h?bt(e(g),void 0,"prehashed message"):g}function U(g,h,x){if(["recovered","canonical"].some(C=>C in x))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:A,extraEntropy:v}=re(x,y);g=$(g,A);const E=K(g),I=vt(f,h),H=[Q(I),Q(E)];if(v!=null&&v!==!1){const C=v===!0?n(u.secretKey):v;H.push(F("extraEntropy",C))}const Z=ht(...H),T=E;function N(C){const V=R(C);if(!f.isValidNot0(V))return;const Y=f.inv(V),q=t.BASE.multiply(V).toAffine(),M=f.create(q.x);if(M===ft)return;const Nt=f.create(Y*f.create(T+M*I));if(Nt===ft)return;let me=(q.x===M?0:2)|Number(q.y&St),Ee=Nt;return m&&S(Nt)&&(Ee=f.neg(Nt),me^=1),new B(M,Ee,me)}return{seed:Z,k2sig:N}}function et(g,h,x={}){g=F("message",g);const{seed:m,k2sig:A}=U(g,h,x);return jn(e.outputLen,f.BYTES,o)(m,A)}function W(g){let h;const x=typeof g=="string"||Ft(g),m=!x&&g!==null&&typeof g=="object"&&typeof g.r=="bigint"&&typeof g.s=="bigint";if(!x&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)h=new B(g.r,g.s);else if(x){try{h=B.fromBytes(F("sig",g),"der")}catch(A){if(!(A instanceof ot.Err))throw A}if(!h)try{h=B.fromBytes(F("sig",g),"compact")}catch{return!1}}return h||!1}function L(g,h,x,m={}){const{lowS:A,prehash:v,format:E}=re(m,y);if(x=F("publicKey",x),h=$(F("message",h),v),"strict"in m)throw new Error("options.strict was renamed to lowS");const I=E===void 0?W(g):B.fromBytes(F("sig",g),E);if(I===!1)return!1;try{const H=t.fromBytes(x);if(A&&I.hasHighS())return!1;const{r:Z,s:T}=I,N=K(h),C=f.inv(T),V=f.create(N*C),Y=f.create(Z*C),q=t.BASE.multiplyUnsafe(V).add(H.multiplyUnsafe(Y));return q.is0()?!1:f.create(q.x)===Z}catch{return!1}}function w(g,h,x={}){const{prehash:m}=re(x,y);return h=$(h,m),B.fromBytes(g,"recovered").recoverPublicKey(h).toBytes()}return Object.freeze({keygen:l,getPublicKey:b,getSharedSecret:d,utils:a,lengths:u,Point:t,sign:et,verify:L,recoverPublicKey:w,Signature:B,hash:e})}function dr(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let n=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(f=>Math.ceil(f/2)))):void 0;const o=xt(e.n,{BITS:t.nBitLength,allowedLengths:n,modFromBytes:t.wrapPrivateKey}),s={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:e,curveOpts:s}}function hr(t){const{CURVE:e,curveOpts:r}=dr(t),n={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:r,hash:t.hash,ecdsaOpts:n}}function br(t,e){const r=e.Point;return Object.assign({},e,{ProjectivePoint:r,CURVE:Object.assign({},t,rn(r.Fn.ORDER,r.Fn.BITS))})}function gr(t){const{CURVE:e,curveOpts:r,hash:n,ecdsaOpts:o}=hr(t),s=ar(e,r),f=ur(s,n,o);return br(t,f)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ye(t,e){const r=n=>gr({...t,hash:n});return{...r(e),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dn={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},hn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},bn={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},wr=xt(dn.p),yr=xt(hn.p),pr=xt(bn.p),oe=ye({...dn,Fp:wr,lowS:!1},Ge);ye({...hn,Fp:yr,lowS:!1},Mn);ye({...bn,Fp:pr,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},$n);function gn(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function it(t,...e){if(!gn(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function Yt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function wn(t,e){it(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const xr=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),ct=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),Wt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),mr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!mr)throw new Error("Non little-endian hardware is not supported");function Er(t){if(typeof t!="string")throw new Error(`string expected, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function _t(t){if(typeof t=="string")t=Er(t);else if(gn(t))t=t.slice();else throw new Error(`Uint8Array expected, got ${typeof t}`);return t}function Br(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}const vr=(t,e)=>(Object.assign(e,t),e);function le(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const o=BigInt(32),s=BigInt(4294967295),f=Number(r>>o&s),i=Number(r&s),c=0,l=4;t.setUint32(e+c,f,n),t.setUint32(e+l,i,n)}const st=16,pe=new Uint8Array(16),tt=ct(pe),Ar=225,Sr=(t,e,r,n)=>{const o=n&1;return{s3:r<<31|n>>>1,s2:e<<31|r>>>1,s1:t<<31|e>>>1,s0:t>>>1^Ar<<24&-(o&1)}},D=t=>(t>>>0&255)<<24|(t>>>8&255)<<16|(t>>>16&255)<<8|t>>>24&255|0;function Ur(t){t.reverse();const e=t[15]&1;let r=0;for(let n=0;n<t.length;n++){const o=t[n];t[n]=o>>>1|r,r=(o&1)<<7}return t[0]^=-e&225,t}const Ir=t=>t>64*1024?8:t>1024?4:2;class yn{constructor(e,r){this.blockLen=st,this.outputLen=st,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,e=_t(e),it(e,16);const n=Wt(e);let o=n.getUint32(0,!1),s=n.getUint32(4,!1),f=n.getUint32(8,!1),i=n.getUint32(12,!1);const c=[];for(let y=0;y<128;y++)c.push({s0:D(o),s1:D(s),s2:D(f),s3:D(i)}),{s0:o,s1:s,s2:f,s3:i}=Sr(o,s,f,i);const l=Ir(r||1024);if(![1,2,4,8].includes(l))throw new Error(`ghash: wrong window size=${l}, should be 2, 4 or 8`);this.W=l;const d=128/l,a=this.windowSize=2**l,u=[];for(let y=0;y<d;y++)for(let p=0;p<a;p++){let S=0,_=0,O=0,B=0;for(let R=0;R<l;R++){if(!(p>>>l-R-1&1))continue;const{s0:P,s1:Q,s2:$,s3:U}=c[l*y+R];S^=P,_^=Q,O^=$,B^=U}u.push({s0:S,s1:_,s2:O,s3:B})}this.t=u}_updateBlock(e,r,n,o){e^=this.s0,r^=this.s1,n^=this.s2,o^=this.s3;const{W:s,t:f,windowSize:i}=this;let c=0,l=0,b=0,d=0;const a=(1<<s)-1;let u=0;for(const y of[e,r,n,o])for(let p=0;p<4;p++){const S=y>>>8*p&255;for(let _=8/s-1;_>=0;_--){const O=S>>>s*_&a,{s0:B,s1:R,s2:K,s3:P}=f[u*i+O];c^=B,l^=R,b^=K,d^=P,u+=1}}this.s0=c,this.s1=l,this.s2=b,this.s3=d}update(e){e=_t(e),Yt(this);const r=ct(e),n=Math.floor(e.length/st),o=e.length%st;for(let s=0;s<n;s++)this._updateBlock(r[s*4+0],r[s*4+1],r[s*4+2],r[s*4+3]);return o&&(pe.set(e.subarray(n*st)),this._updateBlock(tt[0],tt[1],tt[2],tt[3]),tt.fill(0)),this}destroy(){const{t:e}=this;for(const r of e)r.s0=0,r.s1=0,r.s2=0,r.s3=0}digestInto(e){Yt(this),wn(e,this),this.finished=!0;const{s0:r,s1:n,s2:o,s3:s}=this,f=ct(e);return f[0]=r,f[1]=n,f[2]=o,f[3]=s,e}digest(){const e=new Uint8Array(st);return this.digestInto(e),this.destroy(),e}}class Hr extends yn{constructor(e,r){e=_t(e);const n=Ur(e.slice());super(n,r),n.fill(0)}update(e){e=_t(e),Yt(this);const r=ct(e),n=e.length%st,o=Math.floor(e.length/st);for(let s=0;s<o;s++)this._updateBlock(D(r[s*4+3]),D(r[s*4+2]),D(r[s*4+1]),D(r[s*4+0]));return n&&(pe.set(e.subarray(o*st)),this._updateBlock(D(tt[3]),D(tt[2]),D(tt[1]),D(tt[0])),tt.fill(0)),this}digestInto(e){Yt(this),wn(e,this),this.finished=!0;const{s0:r,s1:n,s2:o,s3:s}=this,f=ct(e);return f[0]=r,f[1]=n,f[2]=o,f[3]=s,e.reverse()}}function pn(t){const e=(n,o)=>t(o,n.length).update(_t(n)).digest(),r=t(new Uint8Array(16),0);return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=(n,o)=>t(n,o),e}const Re=pn((t,e)=>new yn(t,e));pn((t,e)=>new Hr(t,e));const ue=16,_r=4,Kt=new Uint8Array(ue),Lr=283;function xe(t){return t<<1^Lr&-(t>>7)}function Te(t,e){let r=0;for(;e>0;e>>=1)r^=t&-(e&1),t=xe(t);return r}const Nr=(()=>{let t=new Uint8Array(256);for(let r=0,n=1;r<256;r++,n^=xe(n))t[r]=n;const e=new Uint8Array(256);e[0]=99;for(let r=0;r<255;r++){let n=t[255-r];n|=n<<8,e[t[r]]=(n^n>>4^n>>5^n>>6^n>>7^99)&255}return e})(),Or=t=>t<<24|t>>>8,se=t=>t<<8|t>>>24;function Rr(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const r=new Uint32Array(256).map((l,b)=>e(t[b])),n=r.map(se),o=n.map(se),s=o.map(se),f=new Uint32Array(256*256),i=new Uint32Array(256*256),c=new Uint16Array(256*256);for(let l=0;l<256;l++)for(let b=0;b<256;b++){const d=l*256+b;f[d]=r[l]^n[b],i[d]=o[l]^s[b],c[d]=t[l]<<8|t[b]}return{sbox:t,sbox2:c,T0:r,T1:n,T2:o,T3:s,T01:f,T23:i}}const xn=Rr(Nr,t=>Te(t,3)<<24|t<<16|t<<8|Te(t,2)),Tr=(()=>{const t=new Uint8Array(16);for(let e=0,r=1;e<16;e++,r=xe(r))t[e]=r;return t})();function Cr(t){it(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:r}=xn,n=ct(t),o=n.length,s=i=>It(r,i,i,i,i),f=new Uint32Array(e+28);f.set(n);for(let i=o;i<f.length;i++){let c=f[i-1];i%o===0?c=s(Or(c))^Tr[i/o-1]:o>6&&i%o===4&&(c=s(c)),f[i]=f[i-o]^c}return f}function Zt(t,e,r,n,o,s){return t[r<<8&65280|n>>>8&255]^e[o>>>8&65280|s>>>24&255]}function It(t,e,r,n,o){return t[e&255|r&65280]|t[n>>>16&255|o>>>16&65280]<<16}function Ce(t,e,r,n,o){const{sbox2:s,T01:f,T23:i}=xn;let c=0;e^=t[c++],r^=t[c++],n^=t[c++],o^=t[c++];const l=t.length/4-2;for(let y=0;y<l;y++){const p=t[c++]^Zt(f,i,e,r,n,o),S=t[c++]^Zt(f,i,r,n,o,e),_=t[c++]^Zt(f,i,n,o,e,r),O=t[c++]^Zt(f,i,o,e,r,n);e=p,r=S,n=_,o=O}const b=t[c++]^It(s,e,r,n,o),d=t[c++]^It(s,r,n,o,e),a=t[c++]^It(s,n,o,e,r),u=t[c++]^It(s,o,e,r,n);return{s0:b,s1:d,s2:a,s3:u}}function qr(t,e){if(!e)return new Uint8Array(t);if(it(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function Vt(t,e,r,n,o){it(r,ue),it(n),o=qr(n.length,o);const s=r,f=ct(s),i=Wt(s),c=ct(n),l=ct(o),b=e?0:12,d=n.length;let a=i.getUint32(b,e),{s0:u,s1:y,s2:p,s3:S}=Ce(t,f[0],f[1],f[2],f[3]);for(let O=0;O+4<=c.length;O+=4)l[O+0]=c[O+0]^u,l[O+1]=c[O+1]^y,l[O+2]=c[O+2]^p,l[O+3]=c[O+3]^S,a=a+1>>>0,i.setUint32(b,a,e),{s0:u,s1:y,s2:p,s3:S}=Ce(t,f[0],f[1],f[2],f[3]);const _=ue*Math.floor(c.length/_r);if(_<d){const O=new Uint32Array([u,y,p,S]),B=xr(O);for(let R=_,K=0;R<d;R++,K++)o[R]=n[R]^B[K]}return o}function Kr(t,e,r,n,o){const s=t.create(r,n.length+((o==null?void 0:o.length)||0));o&&s.update(o),s.update(n);const f=new Uint8Array(16),i=Wt(f);return o&&le(i,0,BigInt(o.length*8),e),le(i,8,BigInt(n.length*8),e),s.update(f),s.digest()}const Zr=vr({blockSize:16,nonceLength:12,tagLength:16},function(e,r,n){if(it(r),r.length===0)throw new Error("aes/gcm: empty nonce");const o=16;function s(i,c,l){const b=Kr(Re,!1,i,l,n);for(let d=0;d<c.length;d++)b[d]^=c[d];return b}function f(){const i=Cr(e),c=Kt.slice(),l=Kt.slice();if(Vt(i,!1,l,l,c),r.length===12)l.set(r);else{const d=Kt.slice(),a=Wt(d);le(a,8,BigInt(r.length*8),!1),Re.create(c).update(r).update(d).digestInto(l)}const b=Vt(i,!1,l,Kt);return{xk:i,authKey:c,counter:l,tagMask:b}}return{encrypt:i=>{it(i);const{xk:c,authKey:l,counter:b,tagMask:d}=f(),a=new Uint8Array(i.length+o);Vt(c,!1,b,i,a);const u=s(l,d,a.subarray(0,a.length-o));return a.set(u,i.length),c.fill(0),a},decrypt:i=>{if(it(i),i.length<o)throw new Error(`aes/gcm: ciphertext less than tagLen (${o})`);const{xk:c,authKey:l,counter:b,tagMask:d}=f(),a=i.subarray(0,-o),u=i.subarray(-o),y=s(l,d,a);if(!Br(y,u))throw new Error("aes/gcm: invalid ghash tag");const p=Vt(c,!1,b,a);return l.fill(0),d.fill(0),c.fill(0),p}}});function Vr(t,e,r){return zt(t),r===void 0&&(r=new Uint8Array(t.outputLen)),Dt(t,Ht(r),Ht(e))}const fe=Uint8Array.from([0]),qe=Uint8Array.of();function $r(t,e,r,n=32){zt(t),$t(n);const o=t.outputLen;if(n>255*o)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(n/o);r===void 0&&(r=qe);const f=new Uint8Array(s*o),i=Dt.create(t,e),c=i._cloneInto(),l=new Uint8Array(i.outputLen);for(let b=0;b<s;b++)fe[0]=b+1,c.update(b===0?qe:l).update(r).update(fe).digestInto(l),f.set(l,o*b),i._cloneInto(c);return i.destroy(),c.destroy(),yt(l,fe),f.slice(0,n)}const Mr=(t,e,r,n,o)=>$r(t,Vr(t,e,r),n,o);function kr(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.slice(r,r+2),16);return e}function Gr(t){const e=String.fromCharCode(...Array.from(t));return btoa(e)}let ie=null;async function jr(){if(ie)return ie;const e=(await mn.get("/api/crypto/public-key")).data.public_key;return ie=e,e}async function Fr(t){if(!t)return t;try{console.log("...");const e=await jr(),r=kr(e);console.log(":",r.length);const n=oe.utils.randomPrivateKey(),o=oe.getPublicKey(n,!1);console.log(":",o.length);const f=oe.getSharedSecret(n,r,!1).slice(1,33);console.log("ECDH :",f.length);const i=new TextEncoder().encode("password-encryption"),c=Mr(Ge,f,void 0,i,32);console.log("HKDF AES:",c.length);const l=new Uint8Array(12),b=new TextEncoder().encode(t),a=Zr(c,l).encrypt(b);console.log("AES-GCM :",a.length);const u=new Uint8Array(o.length+a.length);u.set(o,0),u.set(a,o.length);const y=Gr(u);return console.log(":",y.length),y}catch(e){throw console.error(":",e),new Error(`: ${e}`)}}export{Fr as e};
